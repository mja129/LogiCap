/**
 * Type for initialization values.
 * * false, -1, '0' mean logical 0,
 * * 0, 'x' mean undefined value,
 * * true, 1, '1' mean logical 1.
 */
type InitType = 1 | 0 | -1 | boolean | '1' | '0' | 'x';
/**
 * Type for clonable representations of three-value vectors.
 */
type Clonable3vl = {
    _bits: number;
    _avec: Uint32Array;
    _bvec: Uint32Array;
};
/**
 * Exception for three-value vectors.
 */
export declare class Error3vl extends Error {
    constructor(s: string);
}
/**
 * Three-value logic vectors.
 *
 * This is a data class -- its contents are not mutable. Operations on logic
 * vectors return a freshly allocated vector.
 *
 * The internal representation is two bit vectors: bit vector A and B.
 * The value at position _n_ is encoded by two bits, one at position _n_ in
 * bit vector A, the other at same position in bit vector B. The bit
 * combinations have the following meanings:
 *
 * * A: 0, B: 0 -- logical 0,
 * * A: 0, B: 1 -- undefined value, "x",
 * * A: 1, B: 1 -- logical 1.
 */
export declare class Vector3vl {
    /**
     * Number of bits in the vector.
     */
    private _bits;
    /**
     * Bit vector A.
     */
    private _avec;
    /**
     * Bit vector B.
     */
    private _bvec;
    /**
     * Private constructor for three-value logic vectors.
     *
     * **Only for internal use.**
     *
     * @param bits Number of bits in the vector.
     * @param avec Bit vector A.
     * @param bvec Bit vector B.
     */
    private constructor();
    /**
     * Construct a vector with a constant value at each position.
     *
     * @param bits Number of bits in the vector.
     * @param init Initializer. Recognized values:
     * * false, -1, '0' for logical 0,
     * * 0, 'x' for undefined value,
     * * true, 1, '1' for logical 1.
     */
    static make(bits: number, init: InitType): Vector3vl;
    /**
     * Construct a vector containing only zeros.
     *
     * @param bits Number of bits in the vector.
     */
    static zeros(bits: number): Vector3vl;
    /**
     * Construct a vector containing only ones.
     *
     * @param bits Number of bits in the vector.
     */
    static ones(bits: number): Vector3vl;
    /**
     * Construct a vector containing only undefined values.
     *
     * @param bits Number of bits in the vector.
     */
    static xes(bits: number): Vector3vl;
    /**
     * An empty vector.
     */
    static empty: Vector3vl;
    /**
     * A single one.
     */
    static one: Vector3vl;
    /**
     * A single zero.
     */
    static zero: Vector3vl;
    /**
     * A single undefined value.
     */
    static x: Vector3vl;
    /**
     * Construct a vector containing Boolean value _b_.
     *
     * @param b Boolean value for the vector.
     * @param bits Number of bits in the vector.
     */
    static fromBool(b: boolean, bits?: number): Vector3vl;
    /**
     * Concatenate vectors into a single big vector.
     *
     * @param vs Vectors to concatenate.
     *           Arguments are ordered least significant bit first.
     */
    static concat(...vs: Vector3vl[]): Vector3vl;
    /**
     * Construct a vector from an iterable.
     *
     * This function calls [[fromIteratorAnySkip]] or [[fromIteratorPow2]].
     *
     * @param iter Iterable returning initialization values, least to most
     *             significant. First _skip_ bits go to vector B, next
     *             _skip_ bits go to vector A.
     * @param skip Number of bits in a single iterator step. 1 to 16.
     * @param nbits Number of bits in the vector.
     */
    static fromIterator(iter: Iterable<number>, skip: number, nbits: number): Vector3vl;
    /**
     * Construct a vector from an iterable.
     *
     * This function is more generic, but slower, than [[fromIteratorPow2]].
     *
     * @param iter Iterable returning initialization values, least to most
     *             significant. First _skip_ bits go to vector B, next
     *             _skip_ bits go to vector A.
     * @param skip Number of bits in a single iterator step. 1 to 16.
     * @param nbits Number of bits in the vector.
     */
    static fromIteratorAnySkip(iter: Iterable<number>, skip: number, nbits: number): Vector3vl;
    /**
     * Construct a vector from an iterable.
     *
     * This function is limited to power of 2 _skip_ values.
     * For generic version, see [[fromIteratorAnySkip]].
     *
     * @param iter Iterable returning initialization values, least to most
     *             significant. First _skip_ bits go to vector B, next
     *             _skip_ bits go to vector A.
     * @param skip Number of bits in a single iterator step.
     *             Limited to powers of 2: 1, 2, 4, 8, 16.
     * @param nbits Number of bits in the vector.
     */
    static fromIteratorPow2(iter: Iterable<number>, skip: number, nbits: number): Vector3vl;
    /**
     * Construct a vector from an array of numbers.
     *
     * The following interpretation is used:
     * * -1 for logical 0,
     * * 0 for undefined value,
     * * 1 for logical 1.
     *
     * @param data Input array.
     */
    static fromArray(data: number[]): Vector3vl;
    /**
     * Construct a vector from a binary string.
     *
     * Three characters are accepted:
     * * '0' for logical 0,
     * * 'x' for undefined value,
     * * '1' for logical 1.
     *
     * If _nbits_ is given, _data_ is either truncated, or extended with
     * undefined values.
     *
     * @param data The binary string to be parsed.
     * @param nbits Number of bits in the vector. If omitted, the resulting
     *              vector has number of bits equal to the length of _data_.
     */
    static fromBin(data: string, nbits?: number): Vector3vl;
    /**
     * Construct a vector from an octal number.
     *
     * Characters '0' to '7' and 'x' are accepted. The character 'x'
     * means three undefined bits.
     *
     * If _nbits_ is given, _data_ is either truncated, or extended with
     * undefined values.
     *
     * @param data The octal string to be parsed.
     * @param nbits Number of bits in the vector. If omitted, the resulting
     *              vector has number of bits equal to the length of _data_
     *              times three.
     */
    static fromOct(data: string, nbits?: number): Vector3vl;
    /**
     * Construct a vector from a hexadecimal number.
     *
     * Characters '0' to '9', 'a' to 'f' and 'x' are accepted. The character
     * 'x' means three undefined bits.
     *
     * If _nbits_ is given, _data_ is either truncated, or extended with
     * undefined values.
     *
     * @param data The hexadecimal string to be parsed.
     * @param nbits Number of bits in the vector. If omitted, the resulting
     *              vector has number of bits equal to the length of _data_
     *              times four.
     */
    static fromHex(data: string, nbits?: number): Vector3vl;
    /**
     * Construct a vector from a Verilog-like string.
     */
    static fromString(data: string): Vector3vl;
    /**
     * Construct a vector from clonable representation.
     *
     * @param data The initialization value.
     */
    static fromClonable(data: Clonable3vl): Vector3vl;
    /**
     * Construct a vector from a number or a bigint.
     *
     * If _nbits_ bits are not enough to represent the number, it is
     * truncated. If it's larger, the number is sign-extended.
     * If it is not given, the resulting vector will have enough bits
     * to represent the number completely.
     *
     * @param data The initialization value.
     * @param nbits Number of bits in the vector.
     */
    static fromNumber(data: number | bigint, nbits?: number): Vector3vl;
    /**
     * Number of bits in the vector.
     */
    get bits(): number;
    /**
     * Most significant bit in the vector. Returns -1, 0 or 1.
     */
    get msb(): number;
    /**
     * Least significant bit in the vector. Returns -1, 0 or 1.
     */
    get lsb(): number;
    /**
     * Gets _n_th value in the vector. Returns -1, 0 or 1.
     */
    get(n: number): number;
    /**
     * Tests if the vector is all ones.
     */
    get isHigh(): boolean;
    /**
     * Tests if the vector is all zeros.
     */
    get isLow(): boolean;
    /**
     * Tests if there is any defined bit in the vector.
     */
    get isDefined(): boolean;
    /**
     * Tests if every bit in the vector is defined.
     */
    get isFullyDefined(): boolean;
    /**
     * Bitwise AND of two vectors.
     *
     * The vectors need to be the same bit length.
     *
     * @param v The other vector.
     */
    and(v: Vector3vl): Vector3vl;
    /**
     * Bitwise OR of two vectors.
     *
     * The vectors need to be the same bit length.
     *
     * @param v The other vector.
     */
    or(v: Vector3vl): Vector3vl;
    /**
     * Bitwise XOR of two vectors.
     *
     * The vectors need to be the same bit length.
     *
     * @param v The other vector.
     */
    xor(v: Vector3vl): Vector3vl;
    /**
     * Bitwise NAND of two vectors.
     *
     * The vectors need to be the same bit length.
     *
     * @param v The other vector.
     */
    nand(v: Vector3vl): Vector3vl;
    /**
     * Bitwise NOR of two vectors.
     *
     * The vectors need to be the same bit length.
     *
     * @param v The other vector.
     */
    nor(v: Vector3vl): Vector3vl;
    /**
     * Bitwise XNOR of two vectors.
     *
     * The vectors need to be the same bit length.
     *
     * @param v The other vector.
     */
    xnor(v: Vector3vl): Vector3vl;
    /**
     * Bitwise NOT of a vector. */
    not(): Vector3vl;
    /**
     * Return a vector with 1 on locations with x, the rest with 0.
     */
    xmask(): Vector3vl;
    /**
     * Reducing AND of a vector.
     *
     * ANDs all bits of the vector together, producing a single bit.
     *
     * @returns Singleton vector.
     */
    reduceAnd(): Vector3vl;
    /**
     * Reducing OR of a vector.
     *
     * ORs all bits of the vector together, producing a single bit.
     *
     * @returns Singleton vector.
     */
    reduceOr(): Vector3vl;
    /**
     * Reducing NAND of a vector.
     *
     * NANDs all bits of the vector together, producing a single bit.
     *
     * @returns Singleton vector.
     */
    reduceNand(): Vector3vl;
    /**
     * Reducing NOR of a vector.
     *
     * NORs all bits of the vector together, producing a single bit.
     *
     * @returns Singleton vector.
     */
    reduceNor(): Vector3vl;
    /**
     * Reducing XOR of a vector.
     *
     * XORs all bits of the vector together, producing a single bit.
     *
     * @returns Singleton vector.
     */
    reduceXor(): Vector3vl;
    /**
     * Reducing XNOR of a vector.
     *
     * XNORs all bits of the vector together, producing a single bit.
     *
     * @return Singleton vector.
     */
    reduceXnor(): Vector3vl;
    /**
     * Concatenates vectors, including this one, into a single vector.
     *
     * @param vs The other vectors.
     */
    concat(...vs: Vector3vl[]): Vector3vl;
    /**
     * Return a subvector.
     *
     * Uses same conventions as the slice function for JS arrays.
     *
     * @param start Number of the first bit to include in the result.
     *              If omitted, first bit of the vector is used.
     * @param end Number of the last bit to include in the result, plus one.
     *            If omitted, last bit of the vector is used.
     */
    slice(start?: number, end?: number): Vector3vl;
    /**
     * Returns an iterator describing the vector.
     *
     * In each returned value, first _skip_ bits come from the vector B,
     * the next _skip_ bits come from the vector A.
     *
     * This function calls [[toIteratorAnySkip]] or [[toIteratorPow2]].
     *
     * @param skip Number of bits in a single iterator step. 1 to 16.
     */
    toIterator(skip: number): Generator<number, void, unknown>;
    /**
     * Returns an iterator describing the vector.
     *
     * In each returned value, first _skip_ bits come from the vector B,
     * the next _skip_ bits come from the vector A.
     *
     * @param skip Number of bits in a single iterator step. 1 to 16.
     */
    toIteratorAnySkip(skip: number): Generator<number, void, unknown>;
    /**
     * Returns an iterator describing the vector.
     *
     * In each returned value, first _skip_ bits come from the vector B,
     * the next _skip_ bits come from the vector A.
     *
     * @param skip Number of bits in a single iterator step. 1, 2, 4, 8 or 16.
     */
    toIteratorPow2(skip: number): Generator<number, void, unknown>;
    /** Returns an array representation of the vector.
     *
     * The resulting array contains values -1, 0, 1.
     */
    toArray(): any[];
    /** Returns a binary representation of the vector.
     *
     * Three characters are used:
     * * '0' for logical 0,
     * * 'x' for undefined value,
     * * '1' for logical 1.
     */
    toBin(): string;
    /** Returns an octal representation of the vector.
     *
     * Returned characters can be '0' to '7' and 'x'. An 'x' value is returned
     * if any of the three bits is undefined.
     */
    toOct(): string;
    /** Returns an hexadecimal representation of the vector.
     *
     * Returned characters can be '0' to '9', 'a' to 'f' and 'x'. An 'x' value
     * is returned if any of the four bits is undefined.
     */
    toHex(): string;
    /** Returns a string describing the vector. */
    toString(): string;
    /** Returns an object which can be copied by structured clone. */
    toClonable(): Clonable3vl;
    /** Returns a number representing the vector. */
    toNumber(signed?: boolean): number;
    /** Return a signed number representing the vector. */
    toNumberSigned(): number;
    /** Returns a BigInt representing the vector. */
    toBigInt(signed?: boolean): bigint;
    /** Return a signed BigInt representing the vector. */
    toBigIntSigned(): bigint;
    /** Compares two vectors for equality. */
    eq(v: Vector3vl): boolean;
    /** Normalize the vector.
     *
     * Because of the representation used, if _bits_ is not a multiple
     * of 32, some internal bits do not contribute to the vector value,
     * and for performance reasons can get arbitrary values in the course
     * of computations. This procedure clears these bits.
     * For internal use.
     */
    normalize(): void;
    /** Mask for unused bits.
     *
     * For internal use.
     */
    private get _lastmask();
}
export declare class Mem3vl {
    private _bits;
    private _size;
    private _wpc;
    private _avec;
    private _bvec;
    constructor(bits: number, size: number, val?: number);
    static fromData(data: Vector3vl[]): Mem3vl;
    get bits(): number;
    get words(): number;
    get(i: number): Vector3vl;
    set(i: number, v: Vector3vl): void;
    toJSON(): (string | number)[];
    static fromJSON(bits: any, rep: any): Mem3vl;
    toArray(): Vector3vl[];
    toHex(): string[];
    eq(m: Mem3vl): boolean;
}
export interface Display3vlInterface {
    readonly name: string;
    readonly sort: number;
    readonly pattern: string;
    can(kind: 'read' | 'show', bits: number): boolean;
    read(data: string, bits?: number): Vector3vl;
    show(data: Vector3vl): string;
    validate(data: string, bits?: number): boolean;
    size(bits: number): number;
}
export declare class Display3vlWithRegex {
    #private;
    constructor(pattern: string);
    pattern: string;
    validate(data: string, bits?: number): boolean;
}
export declare class Display3vlHex extends Display3vlWithRegex implements Display3vlInterface {
    constructor();
    name: string;
    sort: number;
    can(kind: 'read' | 'show', bits: number): boolean;
    read(data: string, bits?: number): Vector3vl;
    show(data: Vector3vl): string;
    size(bits: number): number;
}
export declare class Display3vlBin extends Display3vlWithRegex implements Display3vlInterface {
    constructor();
    name: string;
    sort: number;
    can(kind: 'read' | 'show', bits: number): boolean;
    read(data: string, bits?: number): Vector3vl;
    show(data: Vector3vl): string;
    size(bits: number): number;
}
export declare class Display3vlOct extends Display3vlWithRegex implements Display3vlInterface {
    constructor();
    name: string;
    sort: number;
    can(kind: 'read' | 'show', bits: number): boolean;
    read(data: string, bits?: number): Vector3vl;
    show(data: Vector3vl): string;
    size(bits: number): number;
}
export declare class Display3vl {
    private readonly displays;
    constructor();
    addDisplay(display: Display3vlInterface): void;
    usableDisplays(kind: 'read' | 'show', bits: number): string[];
    show(name: string, data: Vector3vl): string;
    read(name: string, data: string, bits?: number): Vector3vl;
    pattern(name: string): string;
    validate(name: string, data: string, bits?: number): boolean;
    size(name: string, bits: number): number;
}
export {};
